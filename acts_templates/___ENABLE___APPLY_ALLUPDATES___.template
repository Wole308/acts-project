#ifdef _DEBUGMODE_CHECKS3
#define _DEBUGMODE_APPLYEDGEUPDATES_PRINTS4
#endif

edge_update_type MISSBUFFER_edgeupdates[NUM_VALID_PEs][EDGE_PACK_SIZE][BLOCKRAM_SIZE];
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edgeupdates complete dim=1	
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edgeupdates complete dim=2	
edge3_type MISSBUFFER_edges[NUM_VALID_PEs][EDGE_PACK_SIZE][BLOCKRAM_SIZE];
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edges complete dim=1	
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edges complete dim=2	

unsigned int MISSBUFFER_edgeupdates_index[NUM_VALID_PEs][EDGE_PACK_SIZE];
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edgeupdates_index complete dim=1	
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edgeupdates_index complete dim=2	
unsigned int MISSBUFFER_edges_index[NUM_VALID_PEs][EDGE_PACK_SIZE];
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edges_index complete dim=1
#pragma HLS ARRAY_PARTITION variable=MISSBUFFER_edges_index complete dim=2	

unsigned int max_sz_eus[NUM_VALID_PEs][EDGE_PACK_SIZE];
#pragma HLS ARRAY_PARTITION variable=max_sz_eus complete

edge_update_vec_dt tmp_buffer[NUM_VALID_PEs][EDGE_UPDATES_CHUNKSZ];	
#pragma HLS ARRAY_PARTITION variable=tmp_buffer complete dim=1
edge3_vec_dt tmp_buffer2[NUM_VALID_PEs][BLOCKRAM_SIZE];	
#pragma HLS ARRAY_PARTITION variable=tmp_buffer2 complete dim=1

edge_update_vec_dt edge_update_vecs[NUM_VALID_PEs];
#pragma HLS ARRAY_PARTITION variable=edge_update_vecs complete
edge3_vec_dt edge3_vecs[NUM_VALID_PEs]; 
#pragma HLS ARRAY_PARTITION variable=edge3_vecs complete
unsigned int offsets[NUM_VALID_PEs];
#pragma HLS ARRAY_PARTITION variable = offsets complete
unsigned int maxs[NUM_VALID_PEs]; 
#pragma HLS ARRAY_PARTITION variable=maxs complete

for(unsigned int n=0; n<NUM_VALID_PEs; n++){ offsets[n] = 0; }	
TOP_APPLY_VERTEX_AND_EDGE_UPDATES: for(unsigned int p_u=0; p_u<globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]; p_u++){
	unsigned int offset = (p_v * globalparams[GLOBALPARAMSCODE__PARAM__NUM_UPARTITIONS]);
	unsigned int max_limit = edgeupdatesptrs[0][offset + p_u].size; 
	unsigned int padding_factor = 1;
	
	#ifdef ___ENABLE___DYNAMICGRAPHANALYTICS___ 
	#ifdef _DEBUGMODE_KERNELPRINTS4 
	if(action.fpga < num_prints){ cout<<"### applying "<<max_limit<<" vertex/edge updates in vpartition "<<p_v<<", upartition "<<p_u<<", PE 0: [PEs "; for(unsigned int n=0; n<NUM_VALID_PEs; n++){ cout<<n<<", "; } cout<<"] [target FPGAs "; for(unsigned int n=0; n<action.numfpgas; n++){ cout<<n<<", "; } cout<<"]"<<endl; } 
	#endif 
	#endif 
		
	// clear indices
	for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
	#pragma HLS UNROLL
		for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
		#pragma HLS UNROLL
			MISSBUFFER_edgeupdates_index[inst][v] = 0;
			MISSBUFFER_edges_index[inst][v] = 0;
		}
	}

	// print summary
	#ifdef _DEBUGMODE_KERNELPRINTS//4
	unsigned int tots_ = 0; unsigned int tots2_ = 0;
	for(unsigned int t=0; t<EDGE_UPDATES_DRAMBUFFER_SIZE; t++){ for(unsigned int inst=0; inst<1; inst++){ for(unsigned int v=0; v<1; v++){ if(URAM_map[inst][v][t].size > 0){ cout<<"------ URAM_map["<<inst<<"]["<<v<<"]["<<t<<"].offset: "<<URAM_map[inst][v][t].offset<<", URAM_map["<<inst<<"]["<<v<<"]["<<t<<"].size: "<<URAM_map[inst][v][t].size<<endl; tots_ += 1; tots2_ += URAM_map[inst][v][t].size; }}}}
	cout<<"acts-apply: summary: used "<<tots_<<" slots (of 8192 slots). tots2: "<<tots2_<<endl;
	#endif 	
	// exit(EXIT_SUCCESS); 

	// map edge updates to URAM
	unsigned int total_sz = EDGE_UPDATES_CHUNKSZ;
	unsigned int batch_sz = 512; 
	LOAD_EDGEUPDATES_LOOP1: for(unsigned int t1=0; t1<(total_sz + (batch_sz-1)) / batch_sz; t1++){
		LOAD_EDGEUPDATES_LOOP1B: for(unsigned int t2=0; t2<batch_sz; t2++){ // NOTE. fixes hanging.
		#pragma HLS PIPELINE II={{context['II_LOAD_EDGEUPDATES_LOOP1']}} // <<<FIXME. II too long>>>
			unsigned int t = (t1 * batch_sz) + t2;
			dretrievemany_edges(globalparams[GLOBALPARAMSCODE__BASEOFFSET__EDGEUPDATES] + t, offsets, t, edge3_vecs, {% include '___HBM___ARGS___.template' %});
			
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
			#pragma HLS UNROLL
				for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
				#pragma HLS UNROLL
					edge_update_type edge_update = edge3_vecs[inst].data[v]; 
					tmp_buffer[inst][t].data[v] = edge_update;
					#ifdef _DEBUGMODE_CHECKS3
					if(edge_update.srcvid != INVALIDDATA && t < total_sz){ checkoutofbounds("acts_kernel::ERROR 8813::", edge_update.srcvid, MAX_UPARTITION_SIZE, t, v, inst); }
					if(edge_update.srcvid != INVALIDDATA && t < total_sz){ checkoutofbounds("acts_kernel::ERROR 7713::", edge_update.srcvid, EDGE_UPDATES_DRAMBUFFER_SIZE, t, v, inst); }
					#endif
					
					unsigned int edge_hashid = hash_edge(edge_update.srcvid, edge_update.dstvid, NAp); 
					#ifdef _DEBUGMODE_KERNELPRINTS//4 
					if(inst==0 && p_u==0 && t<2){ cout<<"$$$ load-edge-updates::["<<inst<<"]["<<t<<"]["<<v<<"]: [edge_update-update: srcvid: "<<edge_update.srcvid<<", dstvid: "<<edge_update.dstvid<<"]---[edge_hashid: "<<edge_hashid<<"]"<<endl; }								
					#endif	
						
					if(URAM_edgeupdates[inst][v][edge_hashid].srcvid == INVALIDDATA){
						#ifdef _DEBUGMODE_KERNELPRINTS//4 
						if(inst==0){ cout<<"$$$ load-edge-updates::["<<inst<<"]["<<t<<"]["<<v<<"]: hit @ "<<edge_hashid<<". [edge_update-update: srcvid: "<<edge_update.srcvid<<", dstvid: "<<edge_update.dstvid<<"]"<<endl; }								
						#endif	
						URAM_edgeupdates[inst][v][edge_hashid] = edge_update; 
					} else {
						#ifdef _DEBUGMODE_KERNELPRINTS//4 
						if(inst==0 && MISSBUFFER_edgeupdates_index[inst][v] < 64){ cout<<"$$$ load-edge-updates::["<<inst<<"]["<<t<<"]["<<v<<"]: miss @ "<<edge_hashid<<". [edge_update-update: srcvid: "<<edge_update.srcvid<<", dstvid: "<<edge_update.dstvid<<"]"<<endl; }								
						#endif	
						MISSBUFFER_edgeupdates[inst][v][MISSBUFFER_edgeupdates_index[inst][v]] = edge_update;
						MISSBUFFER_edgeupdates_index[inst][v] += 1; 
					}
				}
			}
		}
	}
	// exit(EXIT_SUCCESS);

	// print summary
	#ifdef _DEBUGMODE_APPLYEDGEUPDATES_PRINTS4
	if(false){ for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ cout<<"acts-apply: MISSBUFFER_edgeupdates_index[0]["<<v<<"]: "<<MISSBUFFER_edgeupdates_index[0][v]<<endl; }}
	unsigned int total_num_misses_ = 0; for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ total_num_misses_ += MISSBUFFER_edgeupdates_index[0][v]; }
	cout<<"apply-edge-updates: miss summary: total number of misses: "<<total_num_misses_<<" (of "<<EDGE_UPDATES_CHUNKSZ * EDGE_PACK_SIZE<<")"<<endl;
	#endif 
	// exit(EXIT_SUCCESS);

	// (1) apply vertex updates to vertices; (2) edge updates to edges
	unsigned int num_edges_updated = 0; 
	uint512_vec_dt updates_vecs[NUM_VALID_PEs];
	#pragma HLS ARRAY_PARTITION variable=updates_vecs complete
	APPLY_UPDATES_LOOP: for(unsigned int it=0; it<(max_limit + BLOCKRAM_SIZE - 1) / BLOCKRAM_SIZE; it++){
		unsigned int sz = BLOCKRAM_SIZE; if((it + 1) * BLOCKRAM_SIZE > max_limit){ sz = max_limit - (it * BLOCKRAM_SIZE); }
		unsigned int updates_offset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VERTEXUPDATES] + updatesptrs[p_v].offset + (it * BLOCKRAM_SIZE);
		unsigned int edges_offset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VERTEXUPDATES] + updatesptrs[p_v].offset + (it * BLOCKRAM_SIZE);
		
		APPLY_VERTEX_UPDATES_LOOP: for(unsigned int t=0; t<sz; t++){				
		#pragma HLS PIPELINE II={{context['II_APPLY_UPDATES_LOOP1']}} // <<<FIXME. II too long>>>
			dretrievemany_udatesdram(updates_offset + t, updates_vecs, {% include '___HBM___ARGS___.template' %}); // NEW
			
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
			#pragma HLS UNROLL
				for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
				#pragma HLS UNROLL
					tmp_buffer2[inst][t].data[v].srcvid = updates_vecs[inst].data[v].key;
					tmp_buffer2[inst][t].data[v].dstvid = updates_vecs[inst].data[v].value;
				}
			}
			
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){ 
			#pragma HLS UNROLL
				uint512_vec_dt updates_vec = updates_vecs[inst];
				for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){		
				#pragma HLS UNROLL
					keyvalue_t update = updates_vec.data[v];
					unsigned int dstvid_lp = update.key; 
					if(update.key >= MAX_APPLYPARTITION_SIZE){ dstvid_lp = 0; }
					unsigned int dstvid_lpv = dstvid_lp / EDGE_PACK_SIZE;	
					
					#ifdef _DEBUGMODE_KERNELPRINTS//4
					if(t< 160 || true){ std::cout<<"SAMPLE VERTEX UPDATE (APPLY) @: t: "<<t<<", inst: "<<inst<<", v: "<<v<<", update.key: "<<update.key<<", update.value: "<<update.value<<std::endl; }
					#endif
					
					#ifdef _DEBUGMODE_CHECKS3
					if(t < limits[inst]){ checkoutofbounds("acts_kernel::ERROR 727a::", dstvid_lp, MAX_APPLYPARTITION_SIZE, NAp, inst, update.key); checkoutofbounds("acts_kernel::ERROR 727b::", dstvid_lpv, MAX_APPLYPARTITION_VECSIZE, NAp, inst, update.key); }					
					#endif
					vprop_dest_t vprop = URAM_vprop[inst][v][dstvid_lpv];
					vprop_dest_t newprop; newprop.prop = INVALIDDATA; 
					unsigned int new_vprop = reduce_funcG(vprop, update.value, globalparams[GLOBALPARAMSCODE__PARAM__ALGORITHM]);
					if(t < limits[inst]){ 
						#ifdef _DEBUGMODE_KERNELPRINTS_TRACE3
						std::cout<<"APPLY (ACT-PACK) UPDATE SEEN @: t: "<<t<<", inst: ["<<inst<<"]: dstvid_lp: "<<dstvid_lp<<", dstvid_lpv: "<<dstvid_lpv<<", new_vprop: "<<new_vprop<<", vid: "<<update.key<<std::endl;
						#endif
						newprop.prop = new_vprop; 
					}
					URAM_vprop[inst][v][dstvid_lpv].prop = newprop.prop; 
					#ifdef _DEBUGMODE_CHECKS3
					if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___APPLYUPDATES___, 2); }
					#endif 
				}
			}
			
			#ifdef ___ENABLE___IMPORT_EXPORT___
			hidden_import_and_export_function(t, import_offset, export_offset, action.size_import_export, HBM_centerA, HBM_centerB, HBM_import, HBM_export, action);
			#endif 
		}
		
		APPLY_EDGE_UPDATES_LOOP: for(unsigned int t=0; t<sz; t++){
		#pragma HLS PIPELINE II={{context['II_APPLY_EDGEUPDATES_MAINLOOP1D']}}
			for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
			#pragma HLS UNROLL
				edge3_vecs[inst] = tmp_buffer2[inst][t];
				for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){ 
				#pragma HLS UNROLL	
					edge3_type edge = edge3_vecs[inst].data[v];
					unsigned int weight = edge.weight;	

					map_t map; map.size = 0;
					if(edge.srcvid < EDGE_UPDATES_DRAMBUFFER_SIZE){ map = URAM_map[inst][v][edge.srcvid]; }
					
					unsigned int edge_hashid = hash_edge(edge.srcvid, edge.dstvid, NAp); 
					unsigned int eu_weight = 1;
					
					#ifdef _DEBUGMODE_KERNELPRINTS//4 
					if(inst==0 && p_u==0 && llp_set==0 && t<8){ cout<<"### process-edge-updates::["<<inst<<"]["<<t<<"]["<<v<<"]:edges: srcvid: "<<edge.srcvid<<", dstvid: "<<edge.dstvid<<"]---[edge: srcvid: "<<edge.srcvid<<", dstvid: "<<edge.dstvid<<"]---[edge_hashid: "<<edge_hashid<<"]"<<endl; }								
					#endif 
					
					edge_update_type edge_update = URAM_edgeupdates[inst][v][edge_hashid];
					if(edge.srcvid != INVALIDDATA && edge.srcvid == edge_update.srcvid && edge.dstvid == edge_update.dstvid){		
						edge3_vecs[inst].data[v].weight = eu_weight; // += eu_weight; II too long>>>		
						#ifdef _DEBUGMODE_CHECKS3
						if(inst==0){ num_edges_updated += 1; }
						if(inst==0 && false){ cout<<"[process-edge-updates:: hit seen @ ["<<inst<<"]["<<t<<"]["<<v<<"]: [edge.srcvid: "<<edge.srcvid<<", edge.dstvid: "<<edge.dstvid<<"] [edge_update.srcvid: "<<edge_update.srcvid<<", edge_update.dstvid: "<<edge_update.dstvid<<"], edge_hashid: "<<edge_hashid<<"]"<<endl; }
						#endif 
						if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_EDGE_UPDATINGS___, 1); }
					}
				}
			}
		
			dinsertmany_edgesdram(edges_offset + t, edge3_vecs, {% include '___HBM___ARGS___.template' %});
		}
	}
	// exit(EXIT_SUCCESS);	
	
	// print summary
	#ifdef _DEBUGMODE_APPLYEDGEUPDATES_PRINTS4
	cout<<"apply-edges: summary: total number of edges updated : "<<num_edges_updated<<" (of "<<max_limit * EDGE_PACK_SIZE<<")"<<endl;
	#endif 
	// exit(EXIT_SUCCESS);	
	
	// (1) insert new edges; (2) reset URAM buffers
	unsigned int num_edges_inserted = 0; 
	unsigned int edges_offset = globalparams[GLOBALPARAMSCODE__BASEOFFSET__VERTEXUPDATES] + updatesptrs[p_v].offset;// + (it * BLOCKRAM_SIZE);
	EDGE_INSERTIONS_LOOP: for(unsigned int t=0; t<EDGE_UPDATES_CHUNKSZ; t++){
	#pragma HLS PIPELINE II={{context['II_APPLY_EDGEUPDATES_RESETURAMBUFFERS_MAINLOOP1']}}
		for(unsigned int inst=0; inst<NUM_VALID_PEs; inst++){
		#pragma HLS UNROLL
			for(unsigned int v=0; v<EDGE_PACK_SIZE; v++){
			#pragma HLS UNROLL
				edge_update_type edge_update = tmp_buffer[inst][t].data[v];
				unsigned int edge_hashid = hash_edge(edge_update.srcvid, edge_update.dstvid, NAp); 
				
				if(edge_update.srcvid < EDGE_UPDATES_DRAMBUFFER_SIZE){ 
					URAM_edgeupdates[inst][v][edge_hashid].srcvid = INVALIDDATA; //
					URAM_edgeupdates[inst][v][edge_hashid].dstvid = INVALIDDATA; //

					#ifdef _DEBUGMODE_CHECKS3
					if(inst==0){ num_edges_inserted += 1; }
					#endif 
					if(inst==0 && v==0){ update_dramnumclockcycles(_NUMCLOCKCYCLES_, ___CODE___NUMBER_OF_EDGE_INSERTIONS___, 1); }
				}					
				// if(edge_update.srcvid >= EDGE_UPDATES_DRAMBUFFER_SIZE){
				// if(inst==0 && true){ cout<<"[--- process-edge-updates:: ["<<inst<<"]["<<t<<"]["<<v<<"]: [edge_update.srcvid: "<<edge_update.srcvid<<", edge_update.dstvid: "<<edge_update.dstvid<<"]"<<endl; }
				// }					
			}
		}
		
		dinsertmany_edgesdram(edges_offset + t, edge3_vecs, {% include '___HBM___ARGS___.template' %});
	}

	// print summary
	#ifdef _DEBUGMODE_APPLYEDGEUPDATES_PRINTS4
	cout<<"apply-edges: summary: total number of edges inserted : "<<num_edges_inserted<<" (of "<<max_limit * EDGE_PACK_SIZE<<")"<<endl;
	#endif 
	// exit(EXIT_SUCCESS);	

	// print number of hits and misses
	#ifdef _DEBUGMODE_APPLYEDGEUPDATES_PRINTS4
	cout<<"apply-edge-updates: total_num_edge_updates: "<<EDGE_UPDATES_CHUNKSZ * EDGE_PACK_SIZE<<" num_edges_updated: "<<num_edges_updated<<", num_edges_inserted: "<<num_edges_inserted<<", total number of misses: "<<total_num_misses_<<endl;
	#endif 
	// if(p_u==1){ exit(EXIT_SUCCESS);	}
}

		






